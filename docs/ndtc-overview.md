### NDTC（Network Delivery Time Control）算法综述

本节总结 Ageneau & Armitage（Netflix, 2025）提出的 **Network Delivery Time Control (NDTC)** 算法，包括背景与相关工作、FDACE 理论细节、NDTC 控制逻辑、帧对齐/时延控制以及工程实现思路预案。论文全文参考 `file://Ageneau和Armitage - 2025 - Network Delivery Time Control a Novel Approach to Rate Adaptation for Low-Latency Video Flows.pdf`。

---

## 1. 背景与问题定义

云游戏和交互式低延迟视频需要在公网环境下维持极低端到端时延，同时避免自激拥塞导致的排队时延增长和丢包。传统“探满带宽”的拥塞控制（包括很多基于 WebRTC 的方案）大多遵循同一个哲学：

- **目标**：发送码率尽量逼近瓶颈链路容量；
- **手段**：通过额外探测（packet trains、突发）或对时延/丢包的响应来“测出”可用容量，再驱动编码器速率适配；
- **问题**：在交互式场景下，这类 aggressive probing 往往会在链路上引入显著的额外排队，放大时延和抖动，甚至自激丢包。

NDTC 采取了完全不同的思路：

- **目标不是“吃满”容量，而是在不引发拥塞的前提下交付低延迟视频帧**；
- 利用已有媒体流本身作为“探针”，通过 **Frame Dithering Available Capacity Estimation (FDACE)** 估计可用带宽；
- 使用估计到的可用带宽的一部分来设置目标帧大小和发送节奏；
- 仅在极端情况（例如 policer/真实拥塞）下依赖丢包信号作为 backstop。

---

## 2. 相关工作及优缺点

### 2.1 GCC（Google Congestion Control, libwebrtc）

- **核心思路**  
  - 最早在 *MMSys 2016* 和 IETF 草案中提出的 WebRTC 拥塞控制方案 [1][2]。  
  - 利用周期性的 **packet train** 作为探测流，在接收端测量不同列车之间的时延梯度（delay gradient）以判断链路是否过载。  
  - 使用自适应阈值来在队列构建流（例如 TCP）存在时保持竞争力。

- **优点**  
  - 在浏览器/WebRTC 生态中已广泛部署，实践经验丰富。  
  - 能在多种网络环境下保持一定的公平性和吞吐。

- **缺点**  
  - 本质上是主动探测和“吃满带宽”的策略，容易**自激队列**，增加端到端时延和抖动。  
  - 延迟梯度估计对噪声、时钟等比较敏感，参数需要场景化调优。  

### 2.2 SCReAM（Self-Clocked Rate Adaptation for Multimedia）

- **核心思路**  
  - RFC 8298 [3]：通过一个滑动窗口控制 bytes-in-flight，接收端基于单向时延和丢包反馈调节窗口大小。  
  - 编码器码率由拥塞窗口和队列长度等信号协同驱动。

- **优点**  
  - 把“在途字节数”视为一等控制对象，只要 ACK 变慢就立即限制发送，减少在队列中堆积的数据。

- **缺点**  
  - 上行路径（ACK 通道）若有波动，容易导致“过于保守”的码率收缩，带来码率和发送节奏的频繁抖动。  
  - 依赖单向时延估计和多个阈值，实操中需要较多参数调优。

### 2.3 NADA（Network-Assisted Dynamic Adaptation）

- **核心思路**  
  - 试图统一 **隐式信号**（时延、丢包）与 **显式信号**（ECN、AQM 标记）[4][5][6]。  
  - 设计一个综合拥塞指标，引导码率调整。

- **优点**  
  - 在理论上更 general，能自然吸收各种拥塞反馈机制。  

- **缺点**  
  - 在现实公网中，ECN/L4S 等显式信号还未广泛部署，算法能力难以充分发挥。  
  - 对时延/丢包阈值的配置依然敏感。

### 2.4 Salsify / SQP / BurstRTC 等“帧车队”方案

**Salsify** [7]：  
- 把帧拆成多个分片，以未节流（unpaced）的 packet trains 发送，并观测包到达时间差来估计链路容量；  
- 优点是 tighter codec–transport integration；  
- 缺点是突发流量容易触发 burst-induced loss 和队列膨胀。

**SQP** [8]：  
- 把每帧作为一个短时 burst，以明显高于平均视频码率的速度打出，利用到达间隔分布推算容量；  
- 根据估算容量驱动编码码率（一步一步调整）；  
- 依赖对最小单向时延的估计，实际中容易**低估交叉流**，导致 overshoot 与队列构建。

**BurstRTC** [9]：  
- 指出简单的 capacity probing 更接近测量“总容量”而非“可用容量”；  
- 通过只对每帧的一部分做 bursting 来减少侵入性，但仍存在 burst 带来额外丢包的风险。

**与 NDTC 的对比**：  
- 上述方案大多通过**显式 burst/packet-train** 来获取容量信息，本身就可能扰动网络队列；  
- NDTC 则通过**轻量的帧发送时长抖动 + 接收时长观测**获取可用容量估计，避免额外 probe traffic，在设计上更关注“不制造队列”的交互式体验。

---

## 3. NDTC 总体设计概览

NDTC 的核心由两部分组成：

- **FDACE（Frame Dithering Available Capacity Estimation）**：  
  通过对帧发送时长 \\(S_n\\) 做轻微抖动（dithering），从对应的接收时长 \\(R_n\\) 分布中估计可用路径容量 \\(A_n\\)，无需增加额外探测包。
- **NDTC 控制环路**：  
  - 利用估计的 \\(A_n\\) 设置目标帧大小：\\(F_n = T_R A_n\\)，其中 \\(T_R\\) 是目标帧接收时长（严格小于帧间隔 \\(T_F\\)）。  
  - 通过调节帧发送 duration（pacing）和帧大小（编码预算），在不拥塞的前提下保证帧“准时到达”；  
  - 在路径出现严重丢包/ policer 等情况时，通过 AIMD 风格的 backstop 控制快速降码率。

简化理解：

- FDACE 负责“测天气”（当前可用容量）；  
- NDTC 控制回路根据天气决定“船开多快、多大”（帧大小和发送节奏），并确保“不开到翻船”（不自激拥塞）。

---

## 4. FDACE 理论细节（原始公式与含义）

### 4.1 基本量与符号

- \\(S_n\\)：第 \\(n\\) 帧发送的持续时间（通过 pacer 控制，并在 \\(T_S\\) 周围做轻微抖动）。  
- \\(R_n\\)：第 \\(n\\) 帧在接收端观察到的持续时间。  
- \\(L_n\\)：第 \\(n\\) 帧的比特大小（或字节数）。  
- \\(A_n\\)：在第 \\(n\\) 帧时刻估计的 **可用路径容量**。  
- \\(T_F\\)：帧间隔（帧周期）。  
- \\(T_S\\)：目标发送持续时间（小于 \\(T_F\\)）。  
- \\(T_R\\)：目标接收持续时间（小于 \\(T_F\\)，且大于 \\(T_S\\)），用于设定帧大小。

FDACE 的关键观察是：在一段时间窗口内，\\(S_m\\) 和 \\(R_m\\) 之间近似满足线性关系：

\\[
\\frac{R_m}{L_m} = a_n \\frac{S_m}{L_m} + b_n
\\]

其中：

- \\(a_n\\) 大致反映了“发送扩展到接收”的线性比例关系；  
- \\(b_n\\) 则与瓶颈队列/链路特性有关（包括残余排队、交叉流等）。

进一步，论文中给出对接收持续时间的估计：

\\[
R'_m = a_n S_m + b_n L_m
\\]

该式中：

- 第一个项 \\(a_n S_m\\) 主要捕获 pacer 带来的影响；  
- 第二个项 \\(b_n L_m\\) 则是经过瓶颈链路时，帧大小和可用容量之间的关系。

通过对一段时间内观测到的 \\((S_m, R_m, L_m)\\) 做线性拟合，可以得到 \\(a_n, b_n\\) 的估计值；\\(A_n\\) 则由 \\(b_n\\) 进一步推导（论文中详细展开了如何从拟合斜率/截距获得对可用容量的估计）。

### 4.2 Dithering 的作用

如果所有帧都以“固定且完美的”节奏发送，即 \\(S_m\\) 几乎恒定，那么基于 \\((S_m, R_m)\\) 的线性回归会退化——难以区分发送端 pacing 与网络 bottleneck 对接收时长的贡献。  

FDACE 通过对每个帧的发送 duration 做轻微的抖动（dither）：

- 使得 \\(S_m\\) 在一个小范围内变化；  
- 由此，\\(R_m\\) 的变化可以被分解为“由 pacer 引起的部分”和“由网络容量/队列引起的部分”；  
- 不需要额外的探测速率，也不需要向网络注入额外 traffic。

这就是“非侵入式”可用容量估计的关键：**利用原本就要发送的媒体帧** 作为“隐形探测报文”，却不人为推高平均发送速率。

---

## 5. NDTC 控制逻辑细节

### 5.1 目标帧大小与目标时延

NDTC 选择一个目标帧接收持续时间 \\(T_R\\)（小于帧周期 \\(T_F\\)），并根据当前估计的可用容量 \\(A_n\\) 计算目标帧大小：

\\[
F_n = T_R A_n
\\]

为了构建一个正反馈环路（在可用容量上升时提升画质/帧大小）并保持队列不被填满，NDTC 配置：

\\[
T_S < T_R < T_F
\\]

这意味着：

- 每帧发送持续时间 \\(S_n\\)（由 pacer 控制）平均小于 \\(T_R\\)；  
- 帧能够在不占满一个完整帧周期的情况下被“准时”接收，从而在接收侧留下处理/显示缓冲空间。

### 5.2 发送节奏与编码控制

在工程上，NDTC 控制 loop会：

- 按估计的 \\(A_n\\) 设定每帧目标大小 \\(F_n\\)，驱动编码器进行码率或 per-frame budget 调整；  
- 按目标发送 duration \\(T_S\\) 对帧进行 pacing，保证真实发送持续时间 \\(S_n\\) 围绕 \\(T_S\\) 抖动；  
- 利用 FDACE 不断更新 \\(A_n\\)，在网络条件变化时快速更新上述两个控制量。

### 5.3 AIMD Backstop（丢包响应）

尽管 FDACE 强调“非拥塞式”容量估计，论文仍然将 **丢包信号** 作为一种 backstop 机制：

- 在无（或极少）丢包时，NDTC 可以对估计的可用容量 \\(A_n\\) 做适度的加性增加（AIMD 中的 “AI” 部分），逐步爬升帧大小以利用更多带宽；  
- 一旦观察到丢包，NDTC 即对 \\(A_n\\) 做乘性减小（“MD”），快速收缩目标帧大小，避免长期 overshoot。

在 policer+可变容量链路实验中（论文中的图 11），可以看到 NDTC 的目标码率曲线在 policer 和真实容量之间**平滑过渡**，且在容量变化时能够迅速响应而不过度震荡。

---

## 6. 帧对齐与时延控制（Appendix A）

论文附录 A 讨论了如何计算帧对齐延迟 \\(D_m\\)，以尽量减少 pacer 抖动对接收时序的影响。

回顾：

- \\(R'_m = a_n S_m + b_n L_m\\) 是估计的接收持续时间；  
- 为了减小 pacer 抖动带来的变化，NDTC 只对 \\(a_n S_m\\) 这一项进行补偿。

定义：

\\[
D_m = a_n [P(\\Delta) - S_m]
\\]

其中 \\(P(\\Delta)\\) 是某种意义上的“最大 send duration”的量（例如抖动范围的上界）。这样一来：

\\[
D_m + R'_m = a_n P(\\Delta) + b_n L_m
\\]

如果链路没有处于瓶颈（\\(b_n = 0\\)），或者帧大小 \\(L_m\\) 近似恒定，那么 \\(D_m + R'_m\\) 可以保持近似常量。直观上：

- 不改变瓶颈处对帧大小的感知（\\(b_n L_m\\) 部分），  
- 只通过延迟补偿把 pacer 带来的发送抖动“抹平”，让接收端看到更稳定的帧到达时序，减少 jitter。

---

## 7. NDTC 的优越性与适用场景

综合论文的分析与实验结果，NDTC 在以下方面具有明显优势：

- **非侵入式的可用容量估计**：  
  FDACE 不依赖额外的探测报文，也不需要精确的 RTT 或最小单向时延估计，仅通过现有帧流量的轻微抖动即可完成容量感知。

- **对自激拥塞高度克制**：  
  相比 GCC、SQP 等“探满带宽”算法，NDTC 把优化目标直接放在“按时交付帧 + 低排队 + 低自诱丢包”，而不是最大化带宽利用率，更适合云游戏等极度重视交互体验的业务。

- **在 policer / 突变场景下的鲁棒性**：  
  结合 FDACE 与 AIMD backstop，NDTC 能在 policer 和真是容量之间平滑过渡，既不过度饿死应用，也不制造长时间 overshoot。

- **与 AQM / L4S 等新型队列管理机制兼容**：  
  论文指出 NDTC 可以很好地与 FQ-CoDel、CAKE 等队列管理器，以及 L4S [15][16][17] 协同工作。其非队列构建的行为模式有利于与其它公平队列调度策略共存。

---

## 8. 在 `network-ws` 中的工程实现思路（预案）

> 本节仅列出实现 NDTC 的设计要点，为后续在 `src/server_ndtc.go` / `src/client_ndtc.go` 中的具体实现做准备，不包含代码。

### 8.1 需要的观测与统计

在现有 WebRTC + FFmpeg 管线基础上，需要额外采集并记录：

- 发送侧（server）：  
  - 每帧的实际发送持续时间 \\(S_n\\)（基于 pacer 的 send 时间戳）；  
  - 帧大小 \\(L_n\\)（比特或字节）；  
  - 当前目标发送 duration \\(T_S\\)、目标接收 duration \\(T_R\\)。
- 接收侧（client）：  
  - 每帧的接收持续时间 \\(R_n\\)，例如从第一包到最后一包的时间差；  
  - 丢包统计（包括 policer 或真实拥塞导致的 loss）。

这些数据可以通过现有的 metrics 机制（参见 `metrics.go`）扩展为 per-frame CSV 或 JSONL，用于离线分析和在线控制。

### 8.2 模块划分与数据流

建议在 `src` 增加 NDTC 专用模块（命名示例）：

- `fdace_estimator.go`：  
  - 维护一个滑动窗口，缓存最近若干帧的 \\((S_m, R_m, L_m)\\)；  
  - 用线性回归估计 \\(a_n, b_n\\)，输出 \\(A_n\\) 以及用于帧对齐的 \\(D_m\\) 建议值；  
  - 提供简单 API：`UpdateSample(frameID, S, R, L)` / `EstimateCapacity()`.

- `ndtc_controller.go`：  
  - 接收 FDACE 的容量估计 \\(A_n\\) 与 loss 信号；  
  - 维护 NDTC 自身的控制状态（当前目标 \\(A_n\\)、目标 \\(T_S\\)、目标 \\(T_R\\) 等）；  
  - 实现 AIMD backstop：`OnNoLoss()` 时加性增加，`OnLoss()` 时乘性减小；  
  - 输出 per-frame 的 target frame size \\(F_n\\) 和 pacing 参数，用于驱动编码器和 pacer。

- `server_ndtc.go` / `client_ndtc.go`：  
  - 在 server 端集成编码器驱动逻辑（根据 \\(F_n\\) 设置 target bitrate 或 per-frame qp/budget）；  
  - 在 client 端收集 \\(R_n\\) 和 loss 统计并反馈给 server（可以通过 RTP/RTCP 扩展或者侧信道）。

### 8.3 与现有脚本与实验框架的集成

- 在 `scripts/` 中新增 NDTC 相关的实验脚本（如 `server-ndtc.sh` / `client-ndtc.sh`），复用 mahimahi 参数与 session 目录结构：  
  - 每个 session 目录中保存：  
    - NDTC 控制日志（CSV：帧索引、\\(S_n\\)、\\(R_n\\)、\\(L_n\\)、\\(A_n\\)、目标 \\(F_n\\)、是否丢包等）；  
    - 质量评估结果（PSNR/SSIM/VMAF）；  
    - 与 GCC/Salsify 实验一致的 trace、配置和结果布局，便于对比。

- 后续可以在 `docs/` 中再补充一个“NDTC vs GCC/Salsify 的实验对比”文档，利用当前 pipeline（FFmpeg + VMAF + mahimahi）绘制出：  
  - 平均/95/99 分位帧接收时延；  
  - 丢包率、自诱丢包比例；  
  - 有效码率与画质指标（PSNR/SSIM/VMAF）。

---

以上内容为在 `network-ws` 项目中理解和复现 NDTC 算法提供了理论和工程上的完整背景。下一步可以按本文件的“工程实现思路”分解任务，在 `src` 中逐步实现 FDACE 估计模块与 NDTC 控制模块，并通过现有的 WebRTC+mahimahi+FFmpeg 实验管线进行验证。



