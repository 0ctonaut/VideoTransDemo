### Salsify 实时视频系统综述（NSDI 2018）

> 基于论文 *“Salsify: Low-Latency Network Video Through Tighter Integration Between a Video Codec and a Transport Protocol”*（NSDI’18，Fouladi et al.，`nsdi18-fouladi.pdf`）的总结与工程映射。

本文档结构与 `ndtc-overview.md` 保持风格一致，方便后续与 GCC、NDTC 等算法的对比分析。

---

## 一、背景与问题定义

传统实时视频系统（FaceTime、Hangouts、Skype、WebRTC 等）普遍采用“两层控制”的架构：

- **传输/拥塞控制层**：根据往返时延、丢包等信号，在包级别上估计网络的“平均可用带宽”；  
- **视频编码器层**：以传输层给出的带宽估计为输入，通过调整**平均码率和帧率**来控制输出码流。

这种松耦合架构存在几个问题：

1. **控制粒度粗**：编码器往往在数百毫秒甚至秒级时间尺度上调节平均码率，无法针对“每一帧”的瞬时网络状况做优化。  
2. **双重控制回路互相干扰**：传输层和编码器各自有一套控制逻辑，可能在某些时刻互相“打架”（例如传输层刚刚提高带宽估计，编码器也上调质量，导致瞬时突发过大）。  
3. **易触发排队和丢包**：在蜂窝网络（如 LTE）和 Wi‑Fi 等高变动链路上，这种架构容易出现大幅排队延迟和缓冲膨胀。

Salsify 提出的核心观点是：**在当前 codec 本身（如 VP8/VP9/H.264）已经相对成熟的前提下，通过重新设计“传输 + 编解码器”的整体架构，在单帧粒度做紧耦合控制，可以比单纯更换 codec 带来更大的收益**。

论文在多个运营商 LTE / UMTS / Wi‑Fi / 间歇链路的真实 trace 上对比了 Salsify 与 FaceTime、Hangouts、Skype、WebRTC（含 VP9‑SVC）等系统的表现，结果表明在大部分场景下，**Salsify 同时实现了更低的 95% 延迟和更高的平均 SSIM dB**（见论文 Figure 1 与 Figure 11 的汇总表）。

---

## 二、相关工作与现状

### 2.1 商用系统与 WebRTC 参考实现

论文构建了一个可复现实验平台，对如下系统进行了端到端评估：

- Apple FaceTime  
- Google Hangouts  
- Microsoft Skype  
- WebRTC 参考实现（Chrome，VP8）  
- WebRTC（VP9‑SVC）

评估维度包括：

- **视频时延**：平均与 95% 分位延迟；  
- **视频质量**：SSIM（以 dB 形式表示，例如 15 dB、10 dB 等）；  
- 以及基于真实用户实验拟合的 QoE 模型（将延迟和 SSIM dB 映射为主观评分）。

总结出的共性问题是：

1. **控制在秒级时间尺度上进行**，难以及时追踪网络带宽的快速变化；  
2. **传输层与 codec 分离**，无法在单帧级别做端到端优化；  
3. 即使使用了更先进的 codec（例如 VP9‑SVC），在高变动链路上的时延优势也并不明显，反而可能引起更复杂的缓冲行为。

这一点也在论文的 QoE 用户实验中得到印证：研究表明，在一定范围内，**减少 100ms 的视频延迟带来的主观体验提升，相当于增加 1–2 dB 的 SSIM dB 质量**；对驾驶/远程操控类应用，这种“延迟优先”的结论更为明显。

### 2.2 架构创新 vs 编解码器优化

论文的一个重要结论是：**在实时交互视频场景中，继续堆砌更复杂的编码工具（例如从 VP8 升级到 VP9/H.265）带来的收益已经接近边际，而通过架构层面重新组织“传输 + codec”的耦合关系，仍然可以显著改善时延与 QoE**。

Salsify 正是这种架构创新的典型代表：

- 使用已有的 VP8 作为底层编码格式（并非最新、最复杂的 codec）；  
- 但通过纯函数式实现 + per‑frame 控制 + Sprout 风格的网络模型，将整体系统的行为从“平均码率控制”变成了“逐帧预算+传输调度”的统一控制回路。

---

## 三、Salsify 总体架构概览

可以用一句话概括 Salsify：  
**Salsify 将传输层的包级拥塞控制与编解码器的帧级码率控制合并为一个统一的 per‑frame 优化算法。**

核心组成部分：

1. **纯函数式 VP8 编解码器**  
   - 对同一输入帧，codec 可以在多个质量等级（不同 quantizer / 目标 PSNR）下生成多个候选编码版本；  
   - 由于实现是“纯函数式”的（给定输入和参数总是得到相同的输出，不依赖隐式状态），Salsify 可以在发送前离线探索多个候选版本，而不会引入状态不一致问题。

2. **基于 Sprout 的网络容量与排队模型**  
   - 传输层并不是简单地维护一个“带宽估计值”，而是构建了一个**随机模型**，描述未来一段时间内链路吞吐与排队时延的分布；  
   - 该模型利用近期的到达间隔、丢包率等观测进行更新，类似于 Sprout 的思想：通过统计方法估计未来一小段时间窗口里可安全发送的字节数，而不用显式测量 RTT 或尝试刷满链路。

3. **统一的 per‑frame 控制回路**  
   - 对于每一帧：  
     1. 传输层模型给出“在下一段时间内推荐的 bit budget”（基于当前排队和容量估计）；  
     2. codec 根据这个 budget 为该帧生成若干候选编码（不同质量/大小）；  
     3. 从候选集合中选择一个“压缩长度刚好能放进当前 budget”的版本；  
     4. 按照模型建议的发送节奏发出该帧的包。

这种 tight integration 带来的好处是：

- **不再通过“设定一个长期平均码率”来驱动编码器**，而是对每一帧做局部最优决策；  
- **避免两套控制回路互相打架**：容量估计和帧级预算在同一算法中统一决策；  
- **天然偏向低延迟**：因为 per‑frame 决策直接考虑了当前队列与排队风险，优先保证帧按时到达，而不是一味追求带宽利用率。

---

## 四、算法理论细节

本节突出 Salsify 核心思路中的几个关键点，尽量贴近原文的描述，同时用中文解释直觉。

### 4.1 每帧预算与候选编码选择

1. **网络模型输出 per‑frame 预算**  
   - Salsify 的 Sprout-style 模型在每个 RTT 或更短时间尺度上，根据观测到的包到达间隔和丢包事件，推断出“未来一小段时间窗口内可安全发送的字节数分布”；  
   - 从该分布中，系统选取一个相对保守的 quantile（例如某个分位数），作为当前帧的 bit budget，记作 \\(B_t\\)。

2. **codec 生成多个候选编码**  
   - 对于当前待编码的一帧，纯函数式 VP8 codec 会尝试多个不同的 quantizer/质量参数（比如 Q1、Q2、Q3…），得到一组候选编码：  
     \\(\\{ (q_i, L_i, \\text{质量}_i) \\}\\)，其中 \\(L_i\\) 是该候选的压缩长度。  
   - 因为 codec 是纯函数式，这些尝试不会改变内部状态，也不会影响下一帧的编码。

3. **选择最合适的候选**  
   - 在所有候选中，Salsify 会选取一个“压缩长度刚好不超过预算且视觉质量尽可能高”的候选，例如：  
     \\[
       i^* = \\arg\\max_i \\{ \\text{质量}_i : L_i \\leq B_t \\}
     \\]
   - 若所有候选都超过预算，则选取最短的那个（降画质以换取时延）。

4. **发送该帧**  
   - 系统将选择的候选帧拆分为一串 RTP/UDP 包，交由传输层按模型给定的节奏发送，确保不会显著增加队列长度。

### 4.2 Sprout 风格的网络模型

Salsify 所用的网络模型大量借鉴了 Sprout 的思想，其关键点包括：

1. **显式建模链路容量与排队过程**  
   - 假设在未来某时间窗口内，链路可提供的传输机会可以看作一个随机过程（例如泊松或其他更新过程）；  
   - 同时，通过观测包到达间隔和丢包事件，估计当前队列长度及其演化趋势。

2. **从观测到达间隔反推容量分布**  
   - 将最近一段时间内接收方观测到的到达时间序列作为样本，拟合或更新一个描述“单位时间内可成功传输字节数”的分布；  
   - 通过贝叶斯/最大似然等方法（原文使用了具体的统计建模策略）不断修正该分布。

3. **在给定位移窗口内选择安全发送量**  
   - 对于每个决策时刻，模型会给出一个分布 \\(P(C)\\) 表示“未来窗口长度内链路容量”的可能性；  
   - Salsify 从该分布中选取一个保守的 quantile（例如 10% 或 20% 分位），作为本次发送窗口的 bit budget，以降低触发排队/丢包的概率。

4. **映射到 per‑frame 控制**  
   - Salsify 将上述“窗口 budget”直接划分为当前帧的 bit budget，而不是转化为长期平均带宽；  
   - 借助纯函数式 codec 的多候选生成能力，这个 budget 可以被非常细粒度地消耗在单帧上。

### 4.3 避免排队与丢包的策略

Salsify 的目标不是“最大化吞吐”，而是**在保证低尾延迟的前提下尽可能提高视觉质量**。为此，它在以下方面做出设计折中：

- **预算选取保守**：即便链路偶尔可以承载更高码率，Salsify 也不会立即把所有空间填满，而是保持一定的裕度，以容忍未来的突发拥塞；  
- **对丢包敏感**：一旦观测到丢包或大幅排队增长，模型会迅速收缩 budget，迫使后续帧缩小大小，优先恢复低时延；  
- **不使用“填满 pipe”的拥塞控制**：与典型 AIMD 类方案不同，Salsify 的控制逻辑更倾向于在“略低于可用带宽”的区间内运行，以换取更平滑的延迟和更好的交互体验。

---

## 五、工程实现思路（与 `network-ws` 环境的映射）

> 本节不直接实现 Salsify，而是结合当前 `network-ws` 的 Pion WebRTC + FFmpeg + mahimahi + 评估脚本架构，给出一个“工程近似版 Salsify”的设计草图，为后续实现做准备。

### 5.1 在 server 端的映射思路

1. **多候选编码接口（近似纯函数式 codec）**  
   - FFmpeg/H.264 并非真正意义上的纯函数式 codec，但可以通过以下方式模拟“多候选”：  
     - 对同一原始帧，使用不同的编码参数（例如不同 CRF/qp 或不同比特率）各编码一遍，得到多组候选码流；  
     - 这些候选可以暂存在内存或磁盘（例如环形缓冲），并记录各自的长度与理论质量指标（PSNR/SSIM 估计）。  
   - 由于 FFmpeg 编码开销较大，可以考虑：  
     - 预先离线编码多种质量版本的整段视频，在在线实验时按需要选择合适版本的下一帧；  
     - 或者只在部分帧上尝试多候选，其余帧采用简单跟随策略。

2. **简化的 Sprout‑like 容量/排队估计模块**  
   - 基于 `network-ws` 现有的统计采集能力，可以实现一个简化的容量估计模块：  
     - 利用接收端统计的 per‑frame 到达时间和丢包率，估计当前队列长度与平均吞吐；  
     - 通过滑动窗口上的统计（如平均吞吐 + 方差 + 简单的安全系数），给出下一帧的 budget。  
   - 虽然无法完全复刻 Sprout 的随机过程建模，但可以实现一个“保守的随机 budget 估计器”，用于驱动 per‑frame 控制。

3. **与 Pion WebRTC 的集成**  
   - 在 `server_salsify.go` 中，替换/扩展现有的 `writeVideoToTrack`：  
     - 每帧从候选集合中选择一个满足当前 budget 的编码版本；  
     - 将该版本拆分成 H.264 NAL 单元，通过 `TrackLocalStaticSample` 或 RTP 封装发出；  
     - 在发送时控制每个包的发送时间（pacing），以匹配 budget 和模型推荐的节奏。

4. **记录 per‑frame 指标**  
   - 在 session 目录下记录：  
     - 每帧选择的编码方案（qp/CRF、长度、估计质量）；  
     - 模型给出的 budget、实际消耗的 bit 数；  
     - 对应的发送时间窗口与预估排队风险。  
   - 这些数据可用于与 GCC、NDTC 的实验结果做对比（延迟分布、质量分布、丢包率等）。

### 5.2 在 client 端的映射思路

1. **到达时间与缓冲状态监控**  
   - 利用 Pion 的 `TrackRemote.ReadRTP`，记录每一帧的：  
     - 第一包与最后一包的到达时间（估计帧接收时长）；  
     - 包间间隔和乱序/重传情况（估计链路抖动）；  
     - 播放缓冲的排队长度（如果使用自定义渲染/解码管线）。  

2. **向 server 回传统计信息**  
   - 可以通过：  
     - 自定义 RTCP APP/RTCP XR 报文；或  
     - 单独的 WebRTC DataChannel；  
     将 per‑frame 到达统计和简单质量指标回传给 server 用于更新容量/排队模型。  

3. **与现有评估脚本的对接**  
   - 继续使用 `scripts/evaluate.sh` 做线下 SSIM/VMAF 评估；  
   - 在 `session_salsify_*` 目录中记录：  
     - `salsify_client_metrics.csv`（per‑frame 到达与播放延迟）；  
     - `psnr.log` / `ssim.log` / `vmaf.json`；  
     - 便于后续画出“延迟 vs 质量 vs QoE”的三维对比图。

### 5.3 与 GCC / NDTC 的对比实验接口

在 `network-ws` 现有的 NDTC/GCC 实验基础上，可以为 Salsify‑like 实现设计相似的实验入口：

- `scripts/server-salsify.sh` / `scripts/client-salsify.sh`：  
  - 负责启动 Salsify 版 server/client；  
  - 与 `server-gcc.sh` / `server-ndtc.sh` 相同方式集成 mahimahi（`mm-delay` / `mm-loss` / `mm-link`）；  
  - 在每次实验结束后调用 `evaluate.sh` 生成统一格式的质量指标。

这样，可以在相同的网络 trace 和视频内容下，对比：

- 平均 / P95 / P99 的视频延迟；  
*- SSIM/VMAF 分布；  
*- 丢包率、带宽利用率、队列长度分布。  

从而定量再现实验室中论文 Figure 1 / Figure 11 所展示的“在多个移动网络 trace 上，Salsify 相对于 WebRTC/FaceTime/Skype 等系统的时延与质量优势”。

---

## 六、Salsify 的优劣总结

**优势：**

- **单帧粒度的紧耦合架构**：通过统一 per‑frame 控制回路避免“传输层 + codec”双重控制冲突；  
- **低尾延迟与高视觉质量**：在多种实际移动网络 trace 下，相比 FaceTime/Hangouts/Skype/WebRTC（含 VP9‑SVC），Salsify 通常能提供更低的 95% 延迟和更高的平均 SSIM dB；  
- **强调架构创新**：展示了在 codec 技术相对成熟的背景下，通过重构系统架构仍能显著提升 QoE。

**挑战与局限：**

- **对 codec 的实现要求高**：需要一个接近纯函数式的 codec 支持多候选编码探索，这在现有 H.264/FFmpeg 管线中并非易事；  
- **实现复杂度较高**：完整复刻 Sprout 风格的随机容量模型和 per‑frame 调度在工程上成本较大；  
- **与现有生态集成难度**：要在现有 WebRTC/浏览器生态中引入 Salsify 级别的 tight integration，需要对浏览器内核或媒体栈做较大改动。

对你当前的 `network-ws` 项目而言，更现实的路径是：**以 Salsify 的思想为指导，构建一个“工程近似版”的 per‑frame 预算 + 多候选编码 + 保守传输调度系统**，并在相同的 mahimahi + FFmpeg 评估框架下，与 GCC、NDTC 等方案进行系统性对比。上述“工程实现思路”小节已经为这一工作提供了清晰的设计蓝图。 

### Salsify：基于编解码与传输紧耦合的低时延视频系统综述

> 对应论文：*Salsify: Low-Latency Network Video Through Tighter Integration Between a Video Codec and a Transport Protocol*（NSDI 2018）［Fouladi *et al.*，论文文件：[`nsdi18-fouladi.pdf`](nsdi18-fouladi.pdf)］。

本文档在 `network-ws` 项目中总结 Salsify 的关键思想、算法细节、相关工作与优劣势，并给出在本项目环境下的工程实现思路，便于后续实现一个 Salsify‑like 实验管线，与现有 GCC/NDTC/Salsify 等方案对比。

---

## 1 背景与问题与动机

### 1.1 传统实时视频架构的局限

主流实时视频系统（包括 FaceTime、Hangouts、Skype，以及基于 WebRTC 的应用）的架构大致类似：

- **传输协议层**（RTP/UDP + 拥塞控制）负责：  
  - 把编码后的视频比特流打包成 RTP/UDP 包发送；  
  - 基于 RTT、丢包、队列长度等信号估计“可用平均带宽”；  
  - 给编码器提供一个目标**平均码率**（如 1–3 秒时间尺度）。
- **视频编解码器层**（H.264/VP8/VP9 等）负责：  
  - 给定目标码率和帧率，选择量化参数（QP）、GOP 结构等；  
  - 在较长时间窗口上让实际输出码率逼近目标值。

这种“两个独立控制回路”结构的典型问题是：  

- 传输层只知道**字节流速率**，不了解单帧大小/截止时间；  
- 编码器只根据**平均码率**调节，而不知道某一时刻网络是否已经拥塞；  
- 在蜂窝/LTE、Wi‑Fi 等带宽变化剧烈的场景中，容易出现：\n
  - 一旦带宽骤降，编码器在几个 GOP 的时间尺度内才逐渐降码率 → 短时间内继续生成大码率帧；  
  - 传输层只能通过队列/丢包“被动感知”，此时队列已经膨胀，端到端视频时延和尾部时延大幅上升；  
  - 在用户体验上，延迟上升往往比画质下降更难接受（原文中用户实验也证明 100ms 延迟≈1–2 dB SSIM 的体验损失）。

### 1.2 Salsify 的核心理念

Salsify 的出发点是：**在当前 codec 本身已经相对成熟的情况下，通过改变“系统架构”和控制粒度，比单纯更换 codec 更能改善端到端体验**［参见 [nsdi18-fouladi.pdf](nsdi18-fouladi.pdf) §1, §2］。

核心思路可以一句话概括：

> 把“每个包的拥塞控制”和“每一帧的码率控制”合并成**单一的 per‑frame 决策循环**：在每一帧生成时，根据当前的网络容量估计和队列状态，动态为该帧分配 bit 预算，并利用“纯函数式” codec 生成多个候选编码，从中选一个既不会引起排队/丢包、又能保证尽量高画质的版本。

Salsify 不显式设定“目标码率”或“固定帧率”，而是根据网络状态**决定何时发送下一帧、以多大码率发送**，从而在端到端时延和画质之间做实时权衡。

---

## 2 相关工作与现有系统表现

论文系统性评估了多种主流系统在多个真实网络 trace（AT&T LTE、Verizon LTE、T‑Mobile UMTS、室内/室外 Wi‑Fi、间歇性链路等）上的表现［见 [nsdi18-fouladi.pdf](nsdi18-fouladi.pdf) §5, Figure 1 & Figure 11］。

### 2.1 对比对象

被对比的系统包括：

- **FaceTime**（iOS/macOS 内建视频通话）  
- **Google Hangouts**  
- **Skype**  
- **WebRTC（VP8 单层）**  
- **WebRTC（VP9-SVC，可伸缩视频编码）**  
- **Salsify‑1c / Salsify‑2c**：分别为单核与双核版本（1c/2c 表示使用的 CPU 核数）

### 2.2 性能指标

主要关注两个维度：

- **端到端视频时延（video delay）**：  
  - 特别关注 95% 分位（p95）延迟，因为这是用户感知“卡顿”的关键；  
- **视频质量（SSIM dB）**：  
  - 使用结构相似度指标（SSIM）的 dB 版本，越大表示主观画质越好。

结果（以 Figure 1 & Figure 11 为例）显示：

- 在 AT&T LTE 场景下：  
  - Salsify‑1c/2c 的平均/95% 延迟显著低于 WebRTC/FaceTime/Hangouts/Skype；  
  - SSIM dB 也普遍高于或不低于现有系统（在多个 trace 上 Salsify 的平均 SSIM dB 排名靠前）。  
- 在 T‑Mobile UMTS、Wi‑Fi、间歇链路等场景中，Salsify 同样展现出**更低的延迟 + 不逊色甚至更高的画质**。

此外，论文还通过两项用户实验（视频通话与赛车游戏）构建了 QoE 的线性模型，得出**100ms 延迟的改善相当于 1–2 dB SSIM 增益**，进一步强调低延迟的重要性［见 [nsdi18-fouladi.pdf](nsdi18-fouladi.pdf), §6, Figure 10］。

### 2.3 现有系统的共性问题

综合来看，传统系统在设计上的共通点是：

- 采用基于平均码率和帧率的 codec 控制；  
- 拥塞控制（TCP‑like/Google Congestion Control）和 codec 的控制逻辑基本解耦；  
- 无法在每一帧做细粒度的“码率‑时延”权衡；  
- 在带宽抖动大的路径上，缓冲区经常被打满 → 视频端到端延迟和抖动显著上升，用户体验下降。

这正是 Salsify 希望通过架构重构来解决的问题。

---

## 3 Salsify 总体架构与数据流

### 3.1 纯函数式 VP8 编码器

Salsify 使用了一个**纯函数式的 VP8 codec 实现**［参见 [nsdi18-fouladi.pdf](nsdi18-fouladi.pdf), §3］：

- 给定一帧原始图像和一个确定性的编码参数（如量化参数 QP、参考帧选择等），编码结果是**完全确定**的，不依赖任何全局状态；  
- 因此可以在不影响系统状态的前提下，为同一帧生成多种不同质量/码率的候选编码版本（例如不同 QP 对应的多条候选四元组：`<size, PSNR/SSIM, encoding_time, ...>`）；  
- 这些候选版本在被真正发送之前不需要所有都写入网络，而是作为“备选方案”供决策模块选择。

这种设计的关键意义在于：

- 传统 codec 常常有内部状态（参考帧、环路滤波器状态等），不同编码决策会改变未来帧的编码路径；  
- 纯函数式实现保证“离线探索”不会影响后续状态，使 per‑frame 预算分配成为可能。

### 3.2 传输与调度层（Sprout‑like 模型）

在传输侧，Salsify借鉴了 Sprout 等概率模型［论文引用了 Sprout：预估未来一小段时间内链路可提供的字节数］：

- 通过持续观察**包到达间隔、ACK 间隔、丢包**等信息，维护一个关于链路可用容量和队列占用的概率模型；  
- 模型输出一个“未来某个时间窗口内，以某种置信度不会导致超时/排队爆炸的最大可发送字节数”；  
- 这一数值被直接解释为**下一帧的可用 bit budget**，而非长期平均码率。

因此，Salsify 的调度决策过程可以表示为：

1. 模型在当前时间点给出一个**容量预算** `B_next`（字节或比特）；  
2. 编码器对即将发送的下一帧生成多种候选编码，得到一组候选大小 `{L1, L2, ..., Lk}`；  
3. 选择满足 `Li ≤ B_next` 且画质最优（或综合考虑延迟/质量的目标函数）的那个候选；  
4. 以合适的发送节奏将该版本的帧打包进 RTP/UDP 发送；
5. 发送期间持续更新模型，下一帧再重复上述过程。

### 3.3 端到端控制循环（Per‑frame Joint Control）

与传统“传输控制码率、编码器跟随”的双层控制不同，Salsify 把**网络估计与编码决策合并成了一个循环**：

- **输入**：上一帧/若干帧的网络观测（到达时间、丢包、重传情况等）、缓冲区状态；  
- **内部状态**：当前容量模型参数、编码器的参考帧/历史信息、用户 QoE 目标（例如最大可接受延迟）；  
- **输出**：  
  - 下一帧何时发送（是否可以立即发送，还是等待网络空闲）；  
  - 下一帧使用什么量化参数/分辨率，从而控制其码率；  
  - 是否需要跳帧、降分辨率或采用 FEC/重传策略。

这使得 Salsify 在单帧级别即可对**延迟与画质**做出最优（或近似最优）决策，从而显著降低了尾部时延，同时保持较高的视觉质量。

---

## 4 算法与机制的理论细节（贴近原文）

> 下面按照论文结构，尽量贴近原文术语，提炼关键思想和公式，并辅以直观解释。由于篇幅限制，这里不逐一重现全部数学推导，详细公式可参考原文［`nsdi18-fouladi.pdf`］。

### 4.1 帧级预算与候选选择

Salsify 的 per‑frame 决策围绕一个核心问题：**给定当前网络状态，下一帧应该用多高的质量（多大码率）编码、何时发出？**

抽象为一个优化问题：

> 对于即将发送的帧 \\(f_t\\)，给定一组候选编码 \\(\\{c_1, c_2, ..., c_k\\}\\)，每个候选具有码率（或大小） \\(L_i\\)、编码延迟 \\(E_i\\)、预估质量 \\(Q_i\\)，在传输模型给出的预算 \\(B_t\\) 和时延约束 \\(D_{\\max}\\) 下，选择能最大化某个“效用函数” \\(U(Q, D)\\) 的候选。

论文中讨论了不同 QoE 模型（基于 SSIM dB 与延迟的线性组合）的使用方式：  

\\[
\\text{QoE} = \\alpha \\cdot \\text{Quality} - \\beta \\cdot \\text{Delay} + \\gamma
\\]

（原文中具体给出了视频通话和赛车游戏两种场景下的拟合系数［见 [nsdi18-fouladi.pdf](nsdi18-fouladi.pdf), §6, Figure 10］）。Salsify 的 per‑frame 决策可以理解为在每个时间点最大化这一 QoE 估计。

### 4.2 Sprout‑like 传输模型

Sprout 是一个基于随机过程的带宽预测模型：  

- 假设网络队列的到达过程服从某种参数化的随机过程；  
- 利用近期的到达间隔、ACK 间隔、丢包信息估计过程参数；  
- 对“未来一小段时间”内可用带宽的分布进行推断，例如：在 150ms 时间窗口内，以 95% 置信度可以发送多少字节而不超过一定的排队阈值。

Salsify 并不需要完全重建 Sprout 的全部细节，而是使用类似的思想：

- 从**历史到达样本**中构建一个“未来服务曲线”的概率分布；  
- 对于给定的**目标时延上限**（例如 150ms/p95），求解一个对应的“安全发送预算” \\(B_t\\)；  
- 该预算直接用于 per‑frame 预算，而不是像传统 TCP‑friendly 控制那样只给出一个长期平均速率。

### 4.3 避免排队和丢包的策略

### Salsify：通过编解码器与传输层紧耦合实现低时延网络视频（NSDI 2018）

> 对 *Salsify: Low-Latency Network Video through Tighter Integration between a Video Codec and a Transport Protocol* 的总结（NSDI’18，Fouladi 等人）\[ [论文原文](https://www.usenix.org/conference/nsdi18/presentation/fouladi) \]。本文档聚焦于：算法/系统设计细节、相关工作及其优劣、Salsify 的优势，以及在 `network-ws` 环境中的工程实现思路（草图）。

---

## 1 背景与问题定义

### 1.1 传统实时视频系统的架构

大多数实时视频系统（如 FaceTime、Hangouts、Skype、WebRTC）采用“两套解耦控制回路”的架构：

- **传输协议层（TCP/QUIC/自定义 UDP + 拥塞控制）**  
  - 逐包调度、重传、丢包检测和 RTT/带宽估计；
  - 输出一个“平均可用码率/带宽估计”（例如数百毫秒到数秒时间尺度的 moving average）。

- **视频编解码层（H.264/VP8/VP9 等）**  
  - 根据传输层给出的目标码率，设置 GOP 结构、帧率、QP（量化参数）等；
  - 以“长期平均码率”为目标，在编码器内部做自己的速率控制。

这种松散耦合的结果是：

- 传输层和编码器各自有一套独立的速率控制算法；  
- 控制时间尺度偏长，很难对单帧/短时网络波动进行快速反应；  
- 在移动网络（LTE、UMTS、Wi-Fi）等带宽波动剧烈的环境下，容易出现**排队时延大、丢包多**的情况，尤其不利于云游戏、远程驾驶等对交互性要求极高的场景。

### 1.2 Salsify 要解决的问题

Salsify 的出发点是：编码器本身的改进（从 VP8 到 VP9/H.265 等）在这种场景下已经进入“收益递减区”；真正决定体验的是系统架构——

- 现有系统采用“预测平均带宽 → 设定平均码率/帧率”的两层控制，缺乏 **per-frame 粒度的紧耦合**；  
- 容易在链路能力下降时“反应太慢”，造成大队列和延迟飙升；  
- 同时也可能在容量上升时无法及时利用可用带宽。

因此 Salsify 目标是：

- 把“传输层的 per-packet 拥塞控制”和“codec 的 per-frame 码率控制”合并为一个统一算法；  
- 对**每一帧**做单独的“长度与发送时间”优化，而不是调整长期平均 bitrate/frame rate；  
- 在不诱发排队和丢包的前提下，快速适应网络容量变化。

